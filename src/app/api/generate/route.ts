import { NextRequest, NextResponse } from 'next/server'
import { GenerateMessageRequest, GenerateMessageResponse } from '@/lib/types'
import { supabaseHelpers } from '@/lib/supabase'
import { getPromptTemplate } from '@/lib/promptEngine'

export async function POST(request: NextRequest) {
  try {
    const body: GenerateMessageRequest = await request.json()
    
    // Validate request
    if (!body.originalText?.trim()) {
      return NextResponse.json(
        { error: 'Original text is required' },
        { status: 400 }
      )
    }

    if (!['oops', 'ask', 'ask_attorney'].includes(body.mode)) {
      return NextResponse.json(
        { error: 'Invalid mode. Must be oops, ask, or ask_attorney' },
        { status: 400 }
      )
    }

    // Check OpenAI API key
    const openaiApiKey = process.env.OPENAI_API_KEY
    if (!openaiApiKey) {
      return NextResponse.json(
        { error: 'OpenAI API key not configured' },
        { status: 500 }
      )
    }

    // Generate session if not provided
    let sessionId = body.sessionId
    if (!sessionId) {
      sessionId = crypto.randomUUID()
    }

    // Load or create user session
    await supabaseHelpers.getOrCreateSession(sessionId)

    // No caching for generated outputs - always generate fresh content

    // Prepare AI prompt based on mode and language using the proper prompt engine
    const prompt = await generateProperPrompt(
      body.mode, 
      body.originalText, 
      body.recipientName, 
      body.recipientRelationship, 
      body.language, 
      body.replyMode, 
      body.replyContext, 
      body.replyVoice,
      body.originalSenderName,
      body.originalSenderRelationship,
      body.conversationId
    )

    console.log('ü§ñ Generating AI response:', {
      mode: body.mode,
      language: body.language,
      originalText: body.originalText.substring(0, 50) + '...',
      sessionId: sessionId.substring(0, 8) + '...',
      promptLength: prompt.length,
      systemPrompt: getPromptTemplate(body.mode, body.language || 'en').substring(0, 100) + '...'
    })

    // Call OpenAI API
    const startTime = Date.now()
    const aiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: getPromptTemplate(body.mode, body.language || 'en')
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 180,
        temperature: 0.8,
        stop: ["<END>"],
      }),
    })

    const processingTime = Date.now() - startTime

    if (!aiResponse.ok) {
      const errorData = await aiResponse.json()
      console.error('OpenAI API error:', errorData)
      return NextResponse.json(
        { error: 'Failed to generate message', details: errorData },
        { status: aiResponse.status }
      )
    }

    const aiData = await aiResponse.json()
    let generatedText = aiData.choices[0]?.message?.content?.trim()

    console.log('ü§ñ GPT-4o mini raw response:', {
      rawContent: aiData.choices[0]?.message?.content,
      generatedText: generatedText,
      usage: aiData.usage
    })

    if (!generatedText) {
      return NextResponse.json(
        { error: 'No content generated by AI' },
        { status: 500 }
      )
    }

    // Post-process: trim safely if needed to ensure clean completion
    if (generatedText.length > 280) {
      const cutoff = generatedText.slice(0, 280)
      const lastPunct = Math.max(cutoff.lastIndexOf('.'), cutoff.lastIndexOf('!'), cutoff.lastIndexOf('?'))
      generatedText = cutoff.slice(0, lastPunct + 1)
    }

    // Calculate token usage
    const tokensUsed = aiData.usage?.total_tokens || 0
    const costEstimate = (tokensUsed / 1000) * 0.00015 // GPT-4o mini pricing

    console.log('‚úÖ AI generation successful:', {
      tokensUsed,
      processingTime: `${processingTime}ms`,
      textLength: generatedText.length
    })

    // Track analytics (don't await to avoid slowing down response)
    trackAnalytics(body, tokensUsed, costEstimate, processingTime).catch(console.error)

    // Get language ID for database
    const languageId = await getLanguageId(body.language || 'en')

    // Save to database
    const messageData = {
      session_id: sessionId,
      mode: body.mode,
      language_id: languageId,
      original_text: body.originalText.trim(),
      ai_generated_text: generatedText,
      ai_model: 'gpt-4o-mini',
      tokens_used: tokensUsed,
      processing_time_ms: processingTime,
      context_metadata: {
        persona: body.persona,
        relationship: body.relationship,
        language: body.language || 'en'
      }
    }

    // Try to save to database, but don't fail if it doesn't work
    try {
      await supabaseHelpers.saveGeneratedMessage(messageData)
    } catch (dbError) {
      console.warn('‚ö†Ô∏è Failed to save to database:', dbError)
      // Continue anyway - this shouldn't break the user experience
    }

    // Return response
    const response: GenerateMessageResponse = {
      id: crypto.randomUUID(),
      generatedText,
      tokensUsed,
      processingTimeMs: processingTime,
    }

    return NextResponse.json(response)

  } catch (error) {
    console.error('‚ùå API route error:', error)
    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}


// Get language ID from language code
async function getLanguageId(languageCode: string): Promise<string> {
  try {
    const { supabase } = await import('@/lib/supabase')
    
    // First try to find existing language
    const { data: existing } = await supabase
      .from('languages')
      .select('id')
      .eq('code', languageCode)
      .maybeSingle() // Use maybeSingle() instead of single() to avoid 406 error
    
    if (existing?.id) {
      return existing.id
    }

    // If not found, create a new language entry
    const { data: newLang, error: createError } = await supabase
      .from('languages')
      .insert({
        code: languageCode,
        name: languageCode.charAt(0).toUpperCase() + languageCode.slice(1),
        native_name: languageCode.charAt(0).toUpperCase() + languageCode.slice(1),
        country_codes: [],
        is_active: true
      })
      .select('id')
      .single()

    if (createError) {
      console.warn('Failed to create language:', createError)
      // Try to get English as fallback
      const { data: enData } = await supabase
        .from('languages')
        .select('id')
        .eq('code', 'en')
        .maybeSingle() // Use maybeSingle() instead of single() to avoid 406 error
      return enData?.id || '00000000-0000-0000-0000-000000000000'
    }

    return newLang?.id || '00000000-0000-0000-0000-000000000000'
  } catch (error) {
    console.warn('Language ID lookup failed:', error)
    return '00000000-0000-0000-0000-000000000000'
  }
}

async function generateProperPrompt(
  mode: string, 
  originalText: string, 
  recipientName?: string, 
  recipientRelationship?: string, 
  language?: string, 
  replyMode?: boolean, 
  replyContext?: string, 
  replyVoice?: string,
  originalSenderName?: string,
  originalSenderRelationship?: string,
  conversationId?: string
): Promise<string> {
  // Handle reply mode with conversation awareness
  if (replyMode && replyContext) {
    // Build conversation context
    const senderContext = originalSenderName 
      ? ` (${originalSenderName}${originalSenderRelationship ? ` - ${originalSenderRelationship}` : ''})`
      : ''
    
    const recipientContext = recipientName 
      ? ` (addressing ${recipientName}${recipientRelationship ? ` - ${recipientRelationship}` : ''})`
      : ''
    
    let prompt = `You are crafting a ${replyVoice || 'dramatic'} response in a dramatic conversation.

CONVERSATION FLOW:
- ORIGINAL MESSAGE: "${replyContext}" (this was sent TO you)
- YOUR RESPONSE: "${originalText}" (this is what you want to say)
- YOU ARE REPLYING TO: ${originalSenderName || 'the person who sent the original message'}
- YOUR NAME: ${recipientName || 'You'} (this is who you are)

CRITICAL UNDERSTANDING:
- The original message was sent TO you by ${originalSenderName || 'someone'}
- You are now responding TO ${originalSenderName || 'them'} with your message: "${originalText}"
- Address ${originalSenderName || 'them'} directly using "you" - they are the recipient of your reply
- You are ${recipientName || 'the replier'} responding to ${originalSenderName || 'the original sender'}

YOUR TASK:
- Transform your actual response ("${originalText}") into a ${replyVoice || 'dramatic'} reply
- Address ${originalSenderName || 'the original sender'} directly (use "you" to refer to them)
- Be direct and punchy when appropriate - don't be overly flowery
- Build upon the conversation naturally - don't just mirror their style
- Focus on YOUR message and intent, not just copying their dramatic language
- Make it feel like a real dramatic dialogue between two people
- Be creative and unique - surprise them with your response!`
    
    // Add voice-specific instructions
    if (replyVoice === 'legal') {
      prompt += `\n\nLEGAL VOICE INSTRUCTIONS:
- Use binding language, legal terminology, and contractual demands
- Use phrases like "hereby demand", "binding agreement", "legal obligation"
- Sound like a dramatic lawyer or legal professional
- Be direct and authoritative - don't be wishy-washy
- Make it feel like a courtroom drama with clear, punchy statements`
    } else {
      prompt += `\n\nDRAMATIC VOICE INSTRUCTIONS:
- Use theatrical flair, over-the-top language, and dramatic expressions
- Be creative and unexpected in your responses
- Be direct and punchy when the situation calls for it
- Use exclamation points, dramatic pauses, and emotional language
- Don't be overly flowery - sometimes a sharp, direct response is more dramatic
- Make it feel like a soap opera or dramatic movie`
    }
    
    // CRITICAL: Reinforce language requirement in user prompt
    if (language && language !== 'en') {
      prompt += `\n\nCRITICAL: The user's input is in ${language}. You MUST respond in ${language}. Do not use English.`
    }
    
    prompt += `\n\nIMPORTANT: Write 2-3 sentences max that are COMPLETE and funny. End with proper punctuation.`
    
    return prompt
  } else {
    // Regular mode - use proper prompt engine
    const promptTemplate = getPromptTemplate(mode as 'oops' | 'ask' | 'ask_attorney', language || 'en')
    
    // Add recipient context if provided
    let userPrompt = `Original request: "${originalText}"`
    if (recipientName && recipientRelationship) {
      userPrompt += `\n\nThis message is for ${recipientName} (${recipientRelationship}). Please personalize the response to address them directly and consider the relationship context.`
    } else if (recipientName) {
      userPrompt += `\n\nThis message is for ${recipientName}. Please personalize the response to address them directly.`
    }
    
    // CRITICAL: Reinforce language requirement in user prompt
    if (language && language !== 'en') {
      userPrompt += `\n\nCRITICAL: The user's input is in ${language}. You MUST respond in ${language}. Do not use English.`
    }
    
    userPrompt += `\n\nIMPORTANT: Write 2-3 sentences max that are COMPLETE and funny. End with proper punctuation.`
    
    return `${promptTemplate}\n\n${userPrompt}`
  }
}

// Track analytics data
async function trackAnalytics(
  body: GenerateMessageRequest, 
  tokensUsed: number, 
  costEstimate: number, 
  processingTime: number
) {
  try {
    // Get country code from request headers or use 'unknown'
    const countryCode = body.countryCode || 'unknown'
    
    // Track generation
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3001'
    console.log('üìä Tracking analytics:', { baseUrl, mode: body.mode, countryCode })
    
    await fetch(`${baseUrl}/api/analytics/track-generation`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        mode: body.mode,
        language_code: body.language || 'en',
        country_code: countryCode,
        tokens_used: tokensUsed,
        cost_estimate: costEstimate
      })
    }).then(res => {
      if (!res.ok) {
        console.error('Failed to track generation:', res.status, res.statusText)
      } else {
        console.log('‚úÖ Generation tracked successfully')
      }
    }).catch(err => {
      console.error('Error tracking generation:', err)
    })

    // Track API call
    await fetch(`${baseUrl}/api/analytics/track-api-call`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        endpoint: '/api/generate',
        tokens_used: tokensUsed,
        cost_estimate: costEstimate,
        response_time_ms: processingTime
      })
    }).then(res => {
      if (!res.ok) {
        console.error('Failed to track API call:', res.status, res.statusText)
      } else {
        console.log('‚úÖ API call tracked successfully')
      }
    }).catch(err => {
      console.error('Error tracking API call:', err)
    })
  } catch (error) {
    console.error('Failed to track analytics:', error)
    // Don't throw - analytics failure shouldn't break the main flow
  }
}
