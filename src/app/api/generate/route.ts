import { NextRequest, NextResponse } from 'next/server'
import { GenerateMessageRequest, GenerateMessageResponse } from '@/lib/types'
import { supabaseHelpers } from '@/lib/supabase'

export async function POST(request: NextRequest) {
  try {
    const body: GenerateMessageRequest = await request.json()
    
    // Validate request
    if (!body.originalText?.trim()) {
      return NextResponse.json(
        { error: 'Original text is required' },
        { status: 400 }
      )
    }

    if (!['oops', 'ask', 'attorney_ask'].includes(body.mode)) {
      return NextResponse.json(
        { error: 'Invalid mode. Must be oops, ask, or attorney_ask' },
        { status: 400 }
      )
    }

    // Check OpenAI API key
    const openaiApiKey = process.env.OPENAI_API_KEY
    if (!openaiApiKey) {
      return NextResponse.json(
        { error: 'OpenAI API key not configured' },
        { status: 500 }
      )
    }

    // Generate session if not provided
    let sessionId = body.sessionId
    if (!sessionId) {
      sessionId = crypto.randomUUID()
    }

    // Load or create user session
    await supabaseHelpers.getOrCreateSession(sessionId)

    // Check for cached response first (within last 24 hours)
    const cacheKey = `${body.mode}_${body.language || 'en'}_${body.originalText.trim().toLowerCase()}`
    const cachedResponse = await checkCachedResponse(cacheKey, body.language || 'en')
    
    if (cachedResponse) {
      console.log('🎭 Using cached response for:', cacheKey.substring(0, 50) + '...')
      return NextResponse.json({
        id: cachedResponse.id,
        generatedText: cachedResponse.ai_generated_text,
        tokensUsed: cachedResponse.tokens_used || 0,
        processingTimeMs: cachedResponse.processing_time_ms || 0,
        cached: true
      })
    }

    // Prepare AI prompt based on mode and language
    const prompt = generatePrompt(body.mode, body.originalText, body.language || 'en')

    console.log('🤖 Generating AI response:', {
      mode: body.mode,
      language: body.language,
      sessionId: sessionId.substring(0, 8) + '...',
      promptLength: prompt.length
    })

    // Call OpenAI API
    const startTime = Date.now()
    const aiResponse = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: getSystemPrompt(body.mode, body.language || 'en')
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        max_tokens: 600,
        temperature: 0.9,
      }),
    })

    const processingTime = Date.now() - startTime

    if (!aiResponse.ok) {
      const errorData = await aiResponse.json()
      console.error('OpenAI API error:', errorData)
      return NextResponse.json(
        { error: 'Failed to generate message', details: errorData },
        { status: aiResponse.status }
      )
    }

    const aiData = await aiResponse.json()
    const generatedText = aiData.choices[0]?.message?.content?.trim()

    if (!generatedText) {
      return NextResponse.json(
        { error: 'No content generated by AI' },
        { status: 500 }
      )
    }

    // Calculate token usage
    const tokensUsed = aiData.usage?.total_tokens || 0

    console.log('✅ AI generation successful:', {
      tokensUsed,
      processingTime: `${processingTime}ms`,
      textLength: generatedText.length
    })

    // Get language ID for database
    const languageId = await getLanguageId(body.language || 'en')

    // Save to database
    const messageData = {
      session_id: sessionId,
      mode: body.mode,
      language_id: languageId,
      original_text: body.originalText.trim(),
      ai_generated_text: generatedText,
      ai_model: 'gpt-4o-mini',
      tokens_used: tokensUsed,
      processing_time_ms: processingTime,
      context_metadata: {
        persona: body.persona,
        relationship: body.relationship,
        language: body.language || 'en',
        cache_key: cacheKey
      }
    }

    // Try to save to database, but don't fail if it doesn't work
    try {
      await supabaseHelpers.saveGeneratedMessage(messageData)
    } catch (dbError) {
      console.warn('⚠️ Failed to save to database:', dbError)
      // Continue anyway - this shouldn't break the user experience
    }

    // Return response
    const response: GenerateMessageResponse = {
      id: crypto.randomUUID(),
      generatedText,
      tokensUsed,
      processingTimeMs: processingTime,
    }

    return NextResponse.json(response)

  } catch (error) {
    console.error('❌ API route error:', error)
    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

// Check for cached response within last 24 hours
async function checkCachedResponse(cacheKey: string, language: string) {
  try {
    const { supabase } = await import('@/lib/supabase')
    const twentyFourHoursAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
    
    const { data } = await supabase
      .from('generated_messages')
      .select('*')
      .eq('context_metadata->>cache_key', cacheKey)
      .eq('language_id', await getLanguageId(language))
      .gte('created_at', twentyFourHoursAgo)
      .order('created_at', { ascending: false })
      .limit(1)
      .single()

    return data
  } catch (error) {
    console.warn('Cache check failed:', error)
    return null
  }
}

// Get language ID from language code
async function getLanguageId(languageCode: string): Promise<string> {
  try {
    const { supabase } = await import('@/lib/supabase')
    const { data } = await supabase
      .from('languages')
      .select('id')
      .eq('code', languageCode)
      .single()
    
    return data?.id || 'en' // Fallback to English
  } catch (error) {
    console.warn('Language ID lookup failed:', error)
    return 'en'
  }
}

function generatePrompt(mode: string, originalText: string, language: string): string {
  const baseText = `Original request: "${originalText}"`
  
  switch (mode) {
    case 'oops':
      return `${baseText}

Please write an EXTREMELY dramatic, over-the-top, theatrical apology in ${getLanguageName(language)}. Make it hilariously exaggerated and filled with drama. The apology should be:
- Dramatically overstated with fake historical scandal references
- Funny but still heartfelt and sincere
- Use theatrical language, metaphors, and dramatic flair
- Reference made-up historical events (like "The Great Spilled Coffee Incident of 1847")
- Include dramatic gestures and emotional crescendos
- End with a heartfelt resolution and promise of redemption

Make it so dramatic that it turns a simple mistake into an epic tale of redemption worthy of Shakespeare. Use the cultural context and humor appropriate for ${getLanguageName(language)} speakers.`
      
    case 'ask':
      return `${baseText}

Please write a persuasive, dramatic request in ${getLanguageName(language)} that convinces the recipient to say yes. Make it like a manifesto of desire:
- Compelling and passionate with emotional crescendos
- Uses dramatic emotional appeal and storytelling
- Builds urgency and importance like a grand declaration
- Convincing without being manipulative
- Elegant, refined, and theatrical
- Include references to grand gestures and noble causes
- Use the cultural persuasion techniques appropriate for ${getLanguageName(language)} speakers

Be persuasive but not pushy - make it sound like a grand romantic gesture or noble quest.`
      
    case 'attorney_ask':
      return `${baseText}

Please write this request in ${getLanguageName(language)} using fake legal language, dramatic attorney-style arguments, and made-up citations. Include:
- Fake legal statutes with random numbers and dramatic names
- Invented case precedents with theatrical names
- Formal courtroom-style language with dramatic flair
- Made-up legal citations using localized names and places
- Theatrical legal arguments with fake historical cases
- References to non-existent legal codes and regulations
- Use legal terminology appropriate for ${getLanguageName(language)} legal systems

Create fictional legal citations like "Pursuant to Title 47, Section 892.4 of the Interpersonal Request Code of ${getCountryName(language)}..." Make it sound like a dramatic legal brief that's completely fabricated but hilariously convincing.`
      
    default:
      return baseText
  }
}

function getSystemPrompt(mode: string, language: string): string {
  const languageName = getLanguageName(language)
  
  switch (mode) {
    case 'oops':
      return `You are a theatrical drama specialist who turns ordinary apologies into dramatic masterpieces in ${languageName}. Your apologies are:
- Exaggerated and over-the-top with fake historical scandal references
- Humorous but still heartfelt and sincere
- Full of dramatic metaphors, theatrical language, and cultural references
- Memorable and entertaining with made-up historical events
- Sincere despite the theatrical presentation
- Include dramatic gestures and emotional crescendos
- Reference fake historical scandals and events appropriate for ${languageName} culture

Always respond with a single dramatic apology in ${languageName}, no explanations or meta-commentary.`
      
    case 'ask':
      return `You are a master persuader who crafts compelling, elegant requests in ${languageName}. Your writing is:
- Convincing and persuasive like a manifesto of desire
- Emotionally engaging with dramatic storytelling
- Urgent but not pushy, like a grand romantic gesture
- Elegant, refined, and theatrical
- Cleverly argumentative with cultural persuasion techniques
- Include references to grand gestures and noble causes
- Use the cultural context appropriate for ${languageName} speakers

Always respond with a single persuasive request in ${languageName}, no explanations or meta-commentary.`
      
    case 'attorney_ask':
      return `You are a theatrical attorney who argues using completely made-up legal language in ${languageName}. Your writing features:
- Fake legal statutes with random numbers and dramatic names
- Invented case precedents with theatrical names
- Dramatic legal terminology appropriate for ${languageName} legal systems
- Formal courtroom-style presentations with dramatic flair
- Hilariously complex legal arguments with fake historical cases
- References to non-existent legal codes and regulations
- Use localized names and places in legal citations

Create fictional legal citations like "Pursuant to Title 47, Section 892.4 of the Interpersonal Request Code of ${getCountryName(language)}..." Always respond with a single attorney-style request in ${languageName}, no explanations or meta-commentary.`
      
    default:
      return `You are a helpful AI assistant for dramatic communication in ${languageName}.`
  }
}

// Helper function to get language name from code
function getLanguageName(languageCode: string): string {
  const languageMap: Record<string, string> = {
    'en': 'English',
    'es': 'Spanish',
    'fr': 'French',
    'de': 'German',
    'it': 'Italian',
    'pt': 'Portuguese',
    'ru': 'Russian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'ar': 'Arabic',
    'nl': 'Dutch',
    'sv': 'Swedish',
    'no': 'Norwegian',
    'da': 'Danish',
    'fi': 'Finnish',
    'pl': 'Polish',
    'tr': 'Turkish'
  }
  return languageMap[languageCode] || 'English'
}

// Helper function to get country name for legal citations
function getCountryName(languageCode: string): string {
  const countryMap: Record<string, string> = {
    'en': 'the United States',
    'es': 'Spain',
    'fr': 'France',
    'de': 'Germany',
    'it': 'Italy',
    'pt': 'Portugal',
    'ru': 'Russia',
    'ja': 'Japan',
    'ko': 'South Korea',
    'zh': 'China',
    'ar': 'Saudi Arabia',
    'nl': 'the Netherlands',
    'sv': 'Sweden',
    'no': 'Norway',
    'da': 'Denmark',
    'fi': 'Finland',
    'pl': 'Poland',
    'tr': 'Turkey'
  }
  return countryMap[languageCode] || 'the United States'
}
